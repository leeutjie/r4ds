---
output:
  html_document:
    toc: true
    toc_float: true
    theme: lumen
---

```{r global_options, include=FALSE}
knitr::opts_chunk$set(message = FALSE)
```

<br>

This section is part of a series that serves as a condensed summary of the [R for Data Science](http://r4ds.had.co.nz/index.html) book as I work through it. The purpose is to use this series as a quick reference in future.

First, we install/load the relevant packages by installing the [tidyverse](https://www.tidyverse.org/) library. This "package" effectively contains all packages developed by *the* [Hadley Wickham](http://hadley.nz/) that relate to the [tidy data](https://www.jstatsoft.org/article/view/v059i10) way of thinking. This chapter focuses on specific libraries, but we install and load the whole `tidyverse` anyway:

```{r load}
if (!require("tidyverse")) install.packages("tidyverse")
```

Data sets required:

```{r}
library(tidyverse)
library(nycflights13)
```


To work with relational data you need verbs that work with pairs of tables. There are three families of verbs designed to work with relational data:

 + _Mutating joins_, which add new variables to one data frame from matching observations in another.

 + _Filtering joins_, which filter observations from one data frame based on whether or not they match an observation in the other table.

 + _Set operations_, which treat observations as if they were set elements.
 
 
We will use the nycflights13 package to learn about relational data.  nycflights13 contains four tibbles:

+ `airlines` lets you look up the full carrier name from its abbreviated code.

+ `airports` gives information about each airport, identified by the `faa` airport code.

+ `planes` gives information about each plane, identified by its `tailnum`.

+ `weather` gives the weather at each NYC airport for each hour.


# Keys

The variables used to connect each pair of tables are called *keys*. A key is a variable (or set of variables) that uniquely identifies an observation. There are two types of keys:

+ A *primary key* uniquely identifies an observation in its own table.

+ A *foreign key* uniquely identifies an observation in another table.

A variable can be both a primary key and a foreign key. Once you’ve identified the primary keys in your tables, it’s good practice to verify that they do indeed uniquely identify each observation:

```{r}
planes %>% 
  
  count(tailnum) %>% 
  
  filter(n > 1)
```


```{r}
flights %>% 
  
  count(year, month, day, flight) %>% 
  
  filter(n > 1)
```

Sometimes a table doesn’t have an explicit primary key: each row is an observation, but no combination of variables reliably identifies it. For example, what’s the primary key in the `flights` table You might think it would be the date plus the flight or tail number, but neither of those are unique:

```{r}
flights %>% 

  count(year, month, day, flight) %>% 
  
  filter(n > 1)


flights %>% 
  
  count(year, month, day, tailnum) %>% 
  
  filter(n > 1)
```

If a table lacks a primary key, it’s sometimes useful to add one with `mutate()` and `row_number()`. This is called a *surrogate key*. 

A primary key and the corresponding foreign key in another table form a *relation*. Relations are typically one-to-many.


# Mutating Joins

A *mutating join* allows you to combine variables from two tables. It first matches observations by their keys, then copies across variables from one table to the other. The join functions add variables to the right, so if you have a lot of variables already, the new variables won’t get printed out. We'll create a narrower dataset so it is easier to see what's happening: 

```{r}
flights2 <- flights %>% 
  
  select(year:day, hour, origin, dest, tailnum, carrier)

flights2
```

What follows are the key concepts for mutating joins. For more detail, see the actual [chapter](https://r4ds.had.co.nz/relational-data.html#mutating-joins), and this [tweet](https://twitter.com/yutannihilation/status/551572539697143808). You can also run `vignette("two-table")` in your console for more information. 



\

