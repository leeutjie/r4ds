<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />




<title>Data Transformation</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>


</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 51px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 56px;
  margin-top: -56px;
}

.section h2 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h3 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h4 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h5 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h6 {
  padding-top: 56px;
  margin-top: -56px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>


<div class="container-fluid main-container">

<!-- tabsets -->
<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});
</script>

<!-- code folding -->






<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Condensed R4DS</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    R4DS
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="2_data_visualisation.html">Data Visualisation</a>
    </li>
    <li>
      <a href="3_data_transformation.html">Data Transformation</a>
    </li>
    <li>
      <a href="10_tibbles.html">Tibbles</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">



<h1 class="title toc-ignore">Data Transformation</h1>

</div>


<p>This markdown is part of a series that serves as a condensed help guide that I use to explore R and the <em>tidyverse</em> packages as I work through <strong>R for Data Science</strong>, available <a href="http://r4ds.had.co.nz/index.html">here</a>.</p>
<p>First, we install/load the relevant packages by installing the <em>tidyverse</em>. This “package” effectively contains all packages developed by <strong>the</strong> Hadley Wickham:</p>
<pre class="r"><code>if (!require(&quot;tidyverse&quot;)) install.packages(&quot;tidyverse&quot;)
library(&quot;tidyverse&quot;)</code></pre>
<p>In this chapter we use an additional dataset that are installed in the form of packages…</p>
<pre class="r"><code>if (!require(&quot;nycflights13&quot;)) install.packages(&quot;nycflights13&quot;)
library(&quot;nycflights13&quot;)</code></pre>
<div id="data-transformation" class="section level1">
<h1>Data Transformation</h1>
<p>In this chapter we will work primarily with the <em>dplyr</em> package, but we load the entire <em>tidyverse</em> anyway because it’s easy.</p>
<p>The <em>dplyr</em> package works really well with a data object called a <strong>tibble</strong>. Essentially, a tibble is a nicely printable version of a <a href="http://www.r-tutor.com/r-introduction/data-frame">data frame</a>. Tibbles are data frames, but slightly tweaked to work better in the tidyverse. For now, you donâ€™t need to worry about the differences; weâ€™ll come back to tibbles in more detail in the Data Wrangle chapter.</p>
<p>When viewing a <code>tibble</code>, these are the common data types in the columns you’ll come across:</p>
<ul>
<li><p><code>int</code> â€“ integers</p></li>
<li><p><code>dbl</code> â€“ doubles, or real numbers</p></li>
<li><p><code>chr</code> â€“ character vectors or strings</p></li>
<li><p><code>dttm</code> â€“ date-times</p></li>
<li><p><code>lgl</code> â€“ logicals/booleans -&gt; TRUE or FALSE</p></li>
<li><p><code>fctr</code> â€“ factor: which R uses to represent categorical variables with fixed possible values</p></li>
<li><p><code>date</code> â€“ Dates</p></li>
</ul>
<p>When working with a <code>tibble</code> or a <code>data.frame</code> in <strong>dplyr</strong>, the following data data <em>verbs</em> are most commonly used for wrangling data:</p>
<ul>
<li><p><code>filter()</code> â€“ picking observations by their values</p></li>
<li><p><code>arrange()</code> â€“ order your table by rows</p></li>
<li><p><code>select()</code> â€“ pick variables by their names (by column)</p></li>
<li><p><code>mutate()</code> â€“ create new variables with functions based on existing variables</p></li>
<li><p><code>summarise()</code> â€“ collapse many variables down into a single summary</p></li>
<li><p><code>group_by()</code> â€“ this verb is used in conjunction with the above. It changes the scope of each function from operating on the entire dataset to operating on it group-by-group.</p></li>
</ul>
<div id="filter" class="section level3">
<h3>Filter()</h3>
<ul>
<li><p><code>filter()</code> can take the following comparison operators: <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>!=</code> (not equal), and <code>==</code> (tests if equal to).</p></li>
<li><p><code>filter()</code> can also accomodate logical operators: <code>&amp;</code> is â€œandâ€, <code>|</code> is â€œorâ€, <code>!</code> is â€œnotâ€ and <code>%in%</code> locates in a vector or concatenation. Sometimes you can simplify complicated subsetting by remembering De Morganâ€™s law: <code>!(x &amp; y)</code> is the same as <code>!x | !y</code>, and <code>!(x | y)</code> is the same as <code>!x &amp; !y</code>.</p></li>
<li><p><code>filter()</code> also handles NA’s. You can filter NA’s with the <code>is.na()</code> function.</p></li>
<li><p><code>filter()</code> can also be used in conjunction with <code>between()</code> which is a shortcut for <code>x &gt;=</code> left &amp; <code>x &lt;=</code> right, implemented efficiently in C++ for local values, and translated to the appropriate SQL syntax for remote tables.</p></li>
<li><p><code>filter()</code> only includes rows where the condition is <code>TRUE</code>; it excludes both <code>FALSE</code> and <code>NA</code> values. If you want to preserve missing values, ask for them explicitly, as in the example below:</p></li>
</ul>
<pre class="r"><code>df &lt;- tibble(x = c(1, NA, 3))
filter(df, x &gt; 1)</code></pre>
<pre><code>## # A tibble: 1 x 1
##       x
##   &lt;dbl&gt;
## 1     3</code></pre>
<pre class="r"><code>filter(df, is.na(x) | x &gt; 1)</code></pre>
<pre><code>## # A tibble: 2 x 1
##       x
##   &lt;dbl&gt;
## 1    NA
## 2     3</code></pre>
</div>
<div id="arrange" class="section level3">
<h3>Arrange()</h3>
<p>This orders the rows in a tibble. As more column names are provided, each additional column is used to break ties found in preceding columns. Use this verb in conjunction with <code>desc()</code> to sort in descending order.</p>
</div>
<div id="select" class="section level3">
<h3>Select()</h3>
<p><code>select()</code> allows you to rapidly zoom in on a useful subset using operations based on the names of the variables. Here are a few examples:</p>
<pre class="r"><code># Select columns by name
select(flights, year, month, day)</code></pre>
<pre><code>## # A tibble: 336,776 x 3
##     year month   day
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;
##  1  2013     1     1
##  2  2013     1     1
##  3  2013     1     1
##  4  2013     1     1
##  5  2013     1     1
##  6  2013     1     1
##  7  2013     1     1
##  8  2013     1     1
##  9  2013     1     1
## 10  2013     1     1
## # ... with 336,766 more rows</code></pre>
<pre class="r"><code># Select all columns between year and day (inclusive)
select(flights, year:day)</code></pre>
<pre><code>## # A tibble: 336,776 x 3
##     year month   day
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;
##  1  2013     1     1
##  2  2013     1     1
##  3  2013     1     1
##  4  2013     1     1
##  5  2013     1     1
##  6  2013     1     1
##  7  2013     1     1
##  8  2013     1     1
##  9  2013     1     1
## 10  2013     1     1
## # ... with 336,766 more rows</code></pre>
<pre class="r"><code># Select all columns except those from year to day (inclusive)
select(flights, -(year:day))</code></pre>
<pre><code>## # A tibble: 336,776 x 16
##    dep_time sched_dep_time dep_delay arr_time sched_arr_time arr_delay
##       &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;
##  1      517            515         2      830            819        11
##  2      533            529         4      850            830        20
##  3      542            540         2      923            850        33
##  4      544            545        -1     1004           1022       -18
##  5      554            600        -6      812            837       -25
##  6      554            558        -4      740            728        12
##  7      555            600        -5      913            854        19
##  8      557            600        -3      709            723       -14
##  9      557            600        -3      838            846        -8
## 10      558            600        -2      753            745         8
## # ... with 336,766 more rows, and 10 more variables: carrier &lt;chr&gt;,
## #   flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;,
## #   distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre>
<p>There are also a couple of helper functions that can be used within <code>select()</code>:</p>
<ul>
<li><p><code>starts_with(&quot;abc&quot;)</code> â€“ matches names that begin with â€œabcâ€.</p></li>
<li><p><code>ends_with(&quot;xyz&quot;)</code> â€“ matches names that end with â€œxyzâ€.</p></li>
<li><p><code>contains(&quot;ijk&quot;)</code> â€“ matches names that contain â€œijkâ€.</p></li>
<li><p><code>matches(&quot;(.)\\1&quot;)</code> â€“ selects variables that match a regular expression (more on this later).</p></li>
<li><p><code>num_range(&quot;x&quot;, 1:3)</code> â€“ matches <code>x1</code>, <code>x2</code> and <code>x3</code>.</p></li>
</ul>
</div>
<div id="mutate" class="section level3">
<h3>Mutate()</h3>
<p><code>mutate()</code> always adds new columns at the end of your dataset. Here is an example with a thinner dataset:</p>
<pre class="r"><code>flights_sml &lt;- select(flights, 
  year:day, 
  ends_with(&quot;delay&quot;), 
  distance, 
  air_time
)

mutate(flights_sml,
  gain = dep_delay - arr_delay,
  speed = distance / air_time * 60
)</code></pre>
<pre><code>## # A tibble: 336,776 x 9
##     year month   day dep_delay arr_delay distance air_time  gain speed
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1  2013     1     1         2        11     1400      227    -9  370.
##  2  2013     1     1         4        20     1416      227   -16  374.
##  3  2013     1     1         2        33     1089      160   -31  408.
##  4  2013     1     1        -1       -18     1576      183    17  517.
##  5  2013     1     1        -6       -25      762      116    19  394.
##  6  2013     1     1        -4        12      719      150   -16  288.
##  7  2013     1     1        -5        19     1065      158   -24  404.
##  8  2013     1     1        -3       -14      229       53    11  259.
##  9  2013     1     1        -3        -8      944      140     5  405.
## 10  2013     1     1        -2         8      733      138   -10  319.
## # ... with 336,766 more rows</code></pre>
<p>Note that you can refer to columns that youâ€™ve just created:</p>
<pre class="r"><code>mutate(flights_sml,
  gain = dep_delay - arr_delay,
  hours = air_time / 60,
  gain_per_hour = gain / hours
)</code></pre>
<pre><code>## # A tibble: 336,776 x 10
##     year month   day dep_delay arr_delay distance air_time  gain hours
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1  2013     1     1         2        11     1400      227    -9 3.78 
##  2  2013     1     1         4        20     1416      227   -16 3.78 
##  3  2013     1     1         2        33     1089      160   -31 2.67 
##  4  2013     1     1        -1       -18     1576      183    17 3.05 
##  5  2013     1     1        -6       -25      762      116    19 1.93 
##  6  2013     1     1        -4        12      719      150   -16 2.5  
##  7  2013     1     1        -5        19     1065      158   -24 2.63 
##  8  2013     1     1        -3       -14      229       53    11 0.883
##  9  2013     1     1        -3        -8      944      140     5 2.33 
## 10  2013     1     1        -2         8      733      138   -10 2.3  
## # ... with 336,766 more rows, and 1 more variable: gain_per_hour &lt;dbl&gt;</code></pre>
<p>If you only want to keep the new variables, use <code>transmute()</code>:</p>
<pre class="r"><code>transmute(flights,
  gain = dep_delay - arr_delay,
  hours = air_time / 60,
  gain_per_hour = gain / hours
)</code></pre>
<pre><code>## # A tibble: 336,776 x 3
##     gain hours gain_per_hour
##    &lt;dbl&gt; &lt;dbl&gt;         &lt;dbl&gt;
##  1    -9 3.78          -2.38
##  2   -16 3.78          -4.23
##  3   -31 2.67         -11.6 
##  4    17 3.05           5.57
##  5    19 1.93           9.83
##  6   -16 2.5           -6.4 
##  7   -24 2.63          -9.11
##  8    11 0.883         12.5 
##  9     5 2.33           2.14
## 10   -10 2.3           -4.35
## # ... with 336,766 more rows</code></pre>
<p>There are many functions for creating new variables that you can use with <code>mutate()</code>. Thereâ€™s no way to list every possible function that you might use, but hereâ€™s a selection of functions that are frequently useful:</p>
<ul>
<li><p>Arithmetic operators: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>^</code>. These are also useful with aggregate functions like <code>x / sum(x)</code> or <code>y - mean(y)</code>.</p></li>
<li><p>Modular arithmetic: <code>%/%</code> (integer division) and <code>%%</code> (remainder), where <code>x == y * (x %/% y) + (x %% y)</code>. Modular arithmetic is a handy tool because it allows you to break integers up into pieces. For example, in the flights dataset, you can compute <code>hour</code> and <code>minute</code> from <code>dep_time</code> with:</p></li>
</ul>
<pre class="r"><code>transmute(flights,
  dep_time,
  hour = dep_time %/% 100,
  minute = dep_time %% 100
)</code></pre>
<pre><code>## # A tibble: 336,776 x 3
##    dep_time  hour minute
##       &lt;int&gt; &lt;dbl&gt;  &lt;dbl&gt;
##  1      517     5     17
##  2      533     5     33
##  3      542     5     42
##  4      544     5     44
##  5      554     5     54
##  6      554     5     54
##  7      555     5     55
##  8      557     5     57
##  9      557     5     57
## 10      558     5     58
## # ... with 336,766 more rows</code></pre>
<ul>
<li><p>Logs: <code>log()</code>, <code>log2()</code>, <code>log10()</code>. These are useful transformations.</p></li>
<li><p>Offsets: <code>lead()</code> and <code>lag()</code> allow you to refer to leading or lagging values. This allows you to compute running differences (e.g. <code>x - lag(x)</code>) or find when values change (<code>x != lag(x)</code>). They are most useful in conjunction with <code>group_by()</code>.</p></li>
<li><p>Cumulative and rolling aggregates: From base R, the following functions run cumulative sums, products, mins and maxes respectively: <code>cumsum()</code>, <code>cumprod()</code>, <code>cummin()</code> and <code>cummax</code>. <em>dplyr</em> provides <code>cummean()</code>. Finally, the <em>RcppRoll</em> package can provide rolling aggregates.</p></li>
<li><p>Logical comparisons: <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>!=</code>.</p></li>
<li><p>Ranking: Many types of ranking functions exist, but <code>min_rank()</code> and <code>desc()</code> are good ones to start with. See also <code>row_number()</code>, <code>dense_rank()</code>, <code>percent_rank()</code>, <code>cume_dist()</code>, <code>ntile()</code>.</p></li>
</ul>
</div>
<div id="summarise" class="section level3">
<h3>Summarise()</h3>
<p>This data verb collapses a data frame into a single row.</p>
<pre class="r"><code>summarise(flights, delay = mean(dep_delay, na.rm = TRUE))</code></pre>
<pre><code>## # A tibble: 1 x 1
##   delay
##   &lt;dbl&gt;
## 1  12.6</code></pre>
<p><code>summarise()</code> is not terribly useful unless we pair it with <code>group_by()</code>. Adding <code>group_by()</code> changes the unit of analysis from the complete dataset to individual groups. Here is an example where flights are grouped by day, and the average departure time is calculated.</p>
<pre class="r"><code>by_day &lt;- group_by(flights, year, month, day)
summarise(by_day, delay = mean(dep_delay, na.rm = TRUE))</code></pre>
<pre><code>## # A tibble: 365 x 4
## # Groups:   year, month [?]
##     year month   day delay
##    &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt;
##  1  2013     1     1 11.5 
##  2  2013     1     2 13.9 
##  3  2013     1     3 11.0 
##  4  2013     1     4  8.95
##  5  2013     1     5  5.73
##  6  2013     1     6  7.15
##  7  2013     1     7  5.42
##  8  2013     1     8  2.55
##  9  2013     1     9  2.28
## 10  2013     1    10  2.84
## # ... with 355 more rows</code></pre>
<p>At this point it would be useful to read the short sections on <a href="http://r4ds.had.co.nz/transform.html#combining-multiple-operations-with-the-pipe">combining operations with the pipe operator</a> and <a href="http://r4ds.had.co.nz/transform.html#missing-values-1">missing values</a>, also in this chapter.</p>
<p>The nice thing about <code>summarise()</code> is that you can add multiple summaries within the same function:</p>
<pre class="r"><code>flights %&gt;% 
  group_by(dest) %&gt;% 
  summarise(
    count = n(),
    dist = mean(distance, na.rm = TRUE),
    delay = mean(arr_delay, na.rm = TRUE)
  ) %&gt;% 
  filter(count &gt; 20, dest != &quot;HNL&quot;)</code></pre>
<pre><code>## # A tibble: 96 x 4
##    dest  count  dist delay
##    &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1 ABQ     254 1826   4.38
##  2 ACK     265  199   4.85
##  3 ALB     439  143  14.4 
##  4 ATL   17215  757. 11.3 
##  5 AUS    2439 1514.  6.02
##  6 AVL     275  584.  8.00
##  7 BDL     443  116   7.05
##  8 BGR     375  378   8.03
##  9 BHM     297  866. 16.9 
## 10 BNA    6333  758. 11.8 
## # ... with 86 more rows</code></pre>
<p>Whenever you do any aggregation, itâ€™s always a good idea to include either a count <code>(n())</code>, or a count of non-missing values <code>(sum(!is.na(x)))</code>. This way you can check that youâ€™re not drawing conclusions based on very small amounts of data. Here is a quick example of what such an implementation would look like:</p>
<pre class="r"><code># Remove missing values
not_cancelled &lt;- flights %&gt;% 
  filter(!is.na(dep_delay), !is.na(arr_delay))

# Create counts and summaries of the data (average dealy by tail number vs the count of tail numbers per average delay)
delays &lt;- 
  not_cancelled %&gt;% 
  group_by(tailnum) %&gt;% 
  summarise(
    delay = mean(arr_delay, na.rm = TRUE),
    n = n()
  )

# Plot the summarised data
ggplot(data = delays, mapping = aes(x = n, y = delay)) + 
  geom_point(alpha = 1/10)</code></pre>
<p><img src="3_data_transformation_files/figure-html/unnamed-chunk-11-1.png" width="672" /></p>
<p>Sometimes with these plots you want to subset the data to see if more of a pattern exists. The following snippet of code shows a nice way of integrating a chart into the piping functionality:</p>
<pre class="r"><code>delays %&gt;% 
  filter(n &gt; 25) %&gt;% 
  ggplot(mapping = aes(x = n, y = delay)) + 
    geom_point(alpha = 1/10)</code></pre>
<p><img src="3_data_transformation_files/figure-html/unnamed-chunk-12-1.png" width="672" /></p>
<div id="useful-summary-functions" class="section level4">
<h4>Useful Summary Functions</h4>
<p>Just using means, counts, and sum can get you a long way, but R provides many other useful summary functions:</p>
<ul>
<li><strong>Measures of location</strong>: Along with <code>mean()</code>, <code>median()</code> is also useful. Itâ€™s sometimes useful to combine aggregation with logical subsetting:</li>
</ul>
<pre class="r"><code>not_cancelled %&gt;% 
  group_by(year, month, day) %&gt;% 
  summarise(
    avg_delay1 = mean(arr_delay),
    avg_delay2 = mean(arr_delay[arr_delay &gt; 0]) # the average positive delay
  )</code></pre>
<pre><code>## # A tibble: 365 x 5
## # Groups:   year, month [?]
##     year month   day avg_delay1 avg_delay2
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;      &lt;dbl&gt;      &lt;dbl&gt;
##  1  2013     1     1     12.7         32.5
##  2  2013     1     2     12.7         32.0
##  3  2013     1     3      5.73        27.7
##  4  2013     1     4     -1.93        28.3
##  5  2013     1     5     -1.53        22.6
##  6  2013     1     6      4.24        24.4
##  7  2013     1     7     -4.95        27.8
##  8  2013     1     8     -3.23        20.8
##  9  2013     1     9     -0.264       25.6
## 10  2013     1    10     -5.90        27.3
## # ... with 355 more rows</code></pre>
<ul>
<li><p><strong>Measures of spread</strong>: The root mean squared deviation, or standard deviation <code>sd()</code>, The interquartile range <code>IQR()</code> and median absolute deviation <code>mad(x)</code></p></li>
<li><p><strong>Measures of rank:</strong>: <code>min(x)</code>, <code>quantile(x, 0.25)</code>, <code>max(x)</code>. Quantiles are a generalisation of the median. For example, <code>quantile(x, 0.25)</code> will find a value of x that is greater than 25% of the values, and less than the remaining 75%.</p></li>
<li><p><em>Measures of position</em>: <code>first(x)</code>, <code>nth(x, 2)</code>, <code>last(x)</code>. These work similarly to <code>x[1]</code>, <code>x[2]</code>, and <code>x[length(x)]</code> but let you set a default value if that position does not exist (i.e. youâ€™re trying to get the 3rd element from a group that only has two elements). For example, we can find the first and last departure for each day:</p></li>
</ul>
<pre class="r"><code>not_cancelled %&gt;% 
  group_by(year, month, day) %&gt;% 
  summarise(
    first_dep = first(dep_time), 
    last_dep = last(dep_time)
  )</code></pre>
<pre><code>## # A tibble: 365 x 5
## # Groups:   year, month [?]
##     year month   day first_dep last_dep
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;int&gt;    &lt;int&gt;
##  1  2013     1     1       517     2356
##  2  2013     1     2        42     2354
##  3  2013     1     3        32     2349
##  4  2013     1     4        25     2358
##  5  2013     1     5        14     2357
##  6  2013     1     6        16     2355
##  7  2013     1     7        49     2359
##  8  2013     1     8       454     2351
##  9  2013     1     9         2     2252
## 10  2013     1    10         3     2320
## # ... with 355 more rows</code></pre>
<ul>
<li>These functions are complementary to filtering on ranks. Filtering gives you all variables, with each observation in a separate row:</li>
</ul>
<pre class="r"><code>not_cancelled %&gt;% 
  group_by(year, month, day) %&gt;% 
  summarise(
    first_dep = first(dep_time), 
    last_dep = last(dep_time)
  )</code></pre>
<pre><code>## # A tibble: 365 x 5
## # Groups:   year, month [?]
##     year month   day first_dep last_dep
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;int&gt;    &lt;int&gt;
##  1  2013     1     1       517     2356
##  2  2013     1     2        42     2354
##  3  2013     1     3        32     2349
##  4  2013     1     4        25     2358
##  5  2013     1     5        14     2357
##  6  2013     1     6        16     2355
##  7  2013     1     7        49     2359
##  8  2013     1     8       454     2351
##  9  2013     1     9         2     2252
## 10  2013     1    10         3     2320
## # ... with 355 more rows</code></pre>
<ul>
<li><em>Counts</em>: There is <code>n()</code>, which takes no arguments and returns the size of the current group. Use <code>sum(!is.na(x))</code> to count non-missing values and <code>n_distinct(x)</code> to count the number of unique values:</li>
</ul>
<pre class="r"><code># Which destinations have the most carriers?
not_cancelled %&gt;% 
  group_by(dest) %&gt;% 
  summarise(carriers = n_distinct(carrier)) %&gt;% 
  arrange(desc(carriers))</code></pre>
<pre><code>## # A tibble: 104 x 2
##    dest  carriers
##    &lt;chr&gt;    &lt;int&gt;
##  1 ATL          7
##  2 BOS          7
##  3 CLT          7
##  4 ORD          7
##  5 TPA          7
##  6 AUS          6
##  7 DCA          6
##  8 DTW          6
##  9 IAD          6
## 10 MSP          6
## # ... with 94 more rows</code></pre>
<p><code>dplyr</code>’s <code>count()</code> function is also extremely useful - it also does an automatic grouped count:</p>
<pre class="r"><code>not_cancelled %&gt;% 
  count(dest)</code></pre>
<pre><code>## # A tibble: 104 x 2
##    dest      n
##    &lt;chr&gt; &lt;int&gt;
##  1 ABQ     254
##  2 ACK     264
##  3 ALB     418
##  4 ANC       8
##  5 ATL   16837
##  6 AUS    2411
##  7 AVL     261
##  8 BDL     412
##  9 BGR     358
## 10 BHM     269
## # ... with 94 more rows</code></pre>
<p>For this count function it is also possible to provide a weight variable. For example, you could use this to â€œcountâ€ (sum) the total number of miles a plane flew:</p>
<pre class="r"><code>not_cancelled %&gt;% 
  count(tailnum, wt = distance)</code></pre>
<pre><code>## # A tibble: 4,037 x 2
##    tailnum      n
##    &lt;chr&gt;    &lt;dbl&gt;
##  1 D942DN    3418
##  2 N0EGMQ  239143
##  3 N10156  109664
##  4 N102UW   25722
##  5 N103US   24619
##  6 N104UW   24616
##  7 N10575  139903
##  8 N105UW   23618
##  9 N107US   21677
## 10 N108UW   32070
## # ... with 4,027 more rows</code></pre>
<ul>
<li><em>Counts and proportions of logical values</em>: <code>sum(x &gt; 10)</code>,<code>mean(y == 0)</code>. When used with numeric functions, <code>TRUE</code> is converted to 1 and <code>FALSE</code> to 0. This makes <code>sum()</code> and <code>mean()</code> very useful: <code>sum(x)</code> gives the number of <code>TRUE</code>s in <code>x</code>, and <code>mean(x)</code> gives the proportion.</li>
</ul>
<pre class="r"><code># How many flights left before 5am? (these usually indicate delayed
# flights from the previous day)
not_cancelled %&gt;% 
  group_by(year, month, day) %&gt;% 
  summarise(n_early = sum(dep_time &lt; 500))</code></pre>
<pre><code>## # A tibble: 365 x 4
## # Groups:   year, month [?]
##     year month   day n_early
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;   &lt;int&gt;
##  1  2013     1     1       0
##  2  2013     1     2       3
##  3  2013     1     3       4
##  4  2013     1     4       3
##  5  2013     1     5       3
##  6  2013     1     6       2
##  7  2013     1     7       2
##  8  2013     1     8       1
##  9  2013     1     9       3
## 10  2013     1    10       3
## # ... with 355 more rows</code></pre>
<pre class="r"><code># What proportion of flights are delayed by more than an hour?
not_cancelled %&gt;% 
  group_by(year, month, day) %&gt;% 
  summarise(hour_perc = mean(arr_delay &gt; 60))</code></pre>
<pre><code>## # A tibble: 365 x 4
## # Groups:   year, month [?]
##     year month   day hour_perc
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;dbl&gt;
##  1  2013     1     1    0.0722
##  2  2013     1     2    0.0851
##  3  2013     1     3    0.0567
##  4  2013     1     4    0.0396
##  5  2013     1     5    0.0349
##  6  2013     1     6    0.0470
##  7  2013     1     7    0.0333
##  8  2013     1     8    0.0213
##  9  2013     1     9    0.0202
## 10  2013     1    10    0.0183
## # ... with 355 more rows</code></pre>
</div>
<div id="grouping-by-multiple-variables" class="section level4">
<h4>Grouping by Multiple Variables</h4>
<p>When you group by multiple variables, each summary peels off one level of the grouping. That makes it easy to progressively roll up a dataset:</p>
<pre class="r"><code>daily &lt;- group_by(flights, year, month, day)
(per_day   &lt;- summarise(daily, flights = n()))</code></pre>
<pre><code>## # A tibble: 365 x 4
## # Groups:   year, month [?]
##     year month   day flights
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;   &lt;int&gt;
##  1  2013     1     1     842
##  2  2013     1     2     943
##  3  2013     1     3     914
##  4  2013     1     4     915
##  5  2013     1     5     720
##  6  2013     1     6     832
##  7  2013     1     7     933
##  8  2013     1     8     899
##  9  2013     1     9     902
## 10  2013     1    10     932
## # ... with 355 more rows</code></pre>
<pre class="r"><code>(per_month &lt;- summarise(per_day, flights = sum(flights)))</code></pre>
<pre><code>## # A tibble: 12 x 3
## # Groups:   year [?]
##     year month flights
##    &lt;int&gt; &lt;int&gt;   &lt;int&gt;
##  1  2013     1   27004
##  2  2013     2   24951
##  3  2013     3   28834
##  4  2013     4   28330
##  5  2013     5   28796
##  6  2013     6   28243
##  7  2013     7   29425
##  8  2013     8   29327
##  9  2013     9   27574
## 10  2013    10   28889
## 11  2013    11   27268
## 12  2013    12   28135</code></pre>
<pre class="r"><code>(per_year  &lt;- summarise(per_month, flights = sum(flights)))</code></pre>
<pre><code>## # A tibble: 1 x 2
##    year flights
##   &lt;int&gt;   &lt;int&gt;
## 1  2013  336776</code></pre>
<p>Be careful when progressively rolling up summaries: itâ€™s OK for sums and counts, but you need to think about weighting means and variances, and itâ€™s not possible to do it exactly for rank-based statistics like the median. In other words, the sum of groupwise sums is the overall sum, but the median of groupwise medians is not the overall median.</p>
</div>
<div id="ungrouping" class="section level4">
<h4>Ungrouping</h4>
<p>If you need to remove grouping, and return to operations on ungrouped data, use <code>ungroup()</code>.</p>
<pre class="r"><code>daily %&gt;% 
  ungroup() %&gt;%             # no longer grouped by date
  summarise(flights = n())  # all flights</code></pre>
<pre><code>## # A tibble: 1 x 1
##   flights
##     &lt;int&gt;
## 1  336776</code></pre>
</div>
<div id="grouped-mutates-and-filters" class="section level4">
<h4>Grouped mutates (and filters)</h4>
<p>Grouping is most useful in conjunction with <code>summarise()</code>, but you can also do convenient operations with <code>mutate()</code> and <code>filter()</code>:</p>
<ul>
<li>Find the worst members of each group:</li>
</ul>
<pre class="r"><code>flights_sml %&gt;% 
  group_by(year, month, day) %&gt;%
  filter(rank(desc(arr_delay)) &lt; 10)</code></pre>
<pre><code>## # A tibble: 3,306 x 7
## # Groups:   year, month, day [365]
##     year month   day dep_delay arr_delay distance air_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;
##  1  2013     1     1       853       851      184       41
##  2  2013     1     1       290       338     1134      213
##  3  2013     1     1       260       263      266       46
##  4  2013     1     1       157       174      213       60
##  5  2013     1     1       216       222      708      121
##  6  2013     1     1       255       250      589      115
##  7  2013     1     1       285       246     1085      146
##  8  2013     1     1       192       191      199       44
##  9  2013     1     1       379       456     1092      222
## 10  2013     1     2       224       207      550       94
## # ... with 3,296 more rows</code></pre>
<ul>
<li>Find all groups bigger than a threshold:</li>
</ul>
<pre class="r"><code>popular_dests &lt;- flights %&gt;% 
  group_by(dest) %&gt;% 
  filter(n() &gt; 365)
popular_dests</code></pre>
<pre><code>## # A tibble: 332,577 x 19
## # Groups:   dest [77]
##     year month   day dep_time sched_dep_time dep_delay arr_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;
##  1  2013     1     1      517            515         2      830
##  2  2013     1     1      533            529         4      850
##  3  2013     1     1      542            540         2      923
##  4  2013     1     1      544            545        -1     1004
##  5  2013     1     1      554            600        -6      812
##  6  2013     1     1      554            558        -4      740
##  7  2013     1     1      555            600        -5      913
##  8  2013     1     1      557            600        -3      709
##  9  2013     1     1      557            600        -3      838
## 10  2013     1     1      558            600        -2      753
## # ... with 332,567 more rows, and 12 more variables: sched_arr_time &lt;int&gt;,
## #   arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;,
## #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;,
## #   minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre>
<ul>
<li>Standardise to compute per group metrics:</li>
</ul>
<pre class="r"><code>popular_dests %&gt;% 
  filter(arr_delay &gt; 0) %&gt;% 
  mutate(prop_delay = arr_delay / sum(arr_delay)) %&gt;% 
  select(year:day, dest, arr_delay, prop_delay)</code></pre>
<pre><code>## # A tibble: 131,106 x 6
## # Groups:   dest [77]
##     year month   day dest  arr_delay prop_delay
##    &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt;      &lt;dbl&gt;
##  1  2013     1     1 IAH          11  0.000111 
##  2  2013     1     1 IAH          20  0.000201 
##  3  2013     1     1 MIA          33  0.000235 
##  4  2013     1     1 ORD          12  0.0000424
##  5  2013     1     1 FLL          19  0.0000938
##  6  2013     1     1 ORD           8  0.0000283
##  7  2013     1     1 LAX           7  0.0000344
##  8  2013     1     1 DFW          31  0.000282 
##  9  2013     1     1 ATL          12  0.0000400
## 10  2013     1     1 DTW          16  0.000116 
## # ... with 131,096 more rows</code></pre>
<p>Functions that work most naturally in grouped mutates and filters are known as window functions (vs. the summary functions used for summaries). You can learn more about useful window functions in the corresponding vignette: <code>vignette(&quot;window-functions&quot;)</code>.</p>
</div>
</div>
</div>




</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
